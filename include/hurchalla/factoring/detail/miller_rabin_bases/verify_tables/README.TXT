I generated all the miller-rabin hash tables myself (via brute-force searches, the details of which are beyond the scope of discussion here).
I verified their correctness using the verification scripts/cpp files in this folder.  If you wish to verify the hash tables and bases yourself, you can view and run the scripts/cpp files in this folder.  You will need a file that lists the strong base2 psuedoprimes for all numbers < (1<<64):
You can get the strong base-2 psuedoprimes as a two-part 7zip archive that contains the desired file, "strong_psps_to_2_64.txt", from
https://raw.githubusercontent.com/hurchalla/Extra-Files/main/psps.7z.001
https://raw.githubusercontent.com/hurchalla/Extra-Files/main/psps.7z.002

I programmatically created the "strong_psps_to_2_64.txt" file using Jan Feitsma's database of all Fermat base-2 pseudoprimes < (1<<64), available at http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html  See also http://www.janfeitsma.nl/math/psp2/index
(FYI, to create "strong_psps_to_2_64.txt" I performed a miller-rabin base 2 test on Feitsma's Fermat database, and placed into "strong_psps_to_2_64.txt" the pseudoprimes that the base-2 miller-rabin test identified as probably prime.  Assuming Feitsma's database is correct, this results in all base-2 strong pseudoprimes < (1<<64).)


How the verifications work
--------------------------

For miller-rabin bases designed for primality testing numbers < (1<<32), the verifications work by first creating a bit vector via the sieve of Eratosthenes, which serves as a lookup table to check primality of any uint32_t number.  Next, the verification loops over every possible uint32_t or uint16_t value (for 32/16 bit tests respectively), and for each value calls MillerRabinMontgomery::is_prime() (from is_prime_miller_rabin.h) to exercise the targeted bases from the folder miller_rabin_bases.  On each loop iteration, the verification compares the miller-rabin primality result with the bit vector primality lookup result, checking that the results match.

For miller-rabin bases designed for primality testing numbers < (1<<64), the verifications work by relying on the file "strong_psps_to_2_64.txt" mentioned above that contains all the strong base-2 pseudoprimes below (1<<64).  Rather than checking all numbers < (1<<64) which would take decades to complete, the verifications test only the strong base-2 pseudoprimes.  There is no need to check that true primes are identified correctly, because miller-rabin testing by theory will never incorrectly identify a prime as composite.  There is also no need to check composites that are not base-2 pseudoprimes, because by definition any composite that is not a base-2 pseudoprime will be correctly identified as composite by a base 2 miller-rabin trial.  The miller-rabin bases designed to primality test numbers < (1<<64) all start with 2 for the first base, and thus miller-rabin testing with those bases always will correctly identify a composite that is not a base-2 pseudoprime.  This leaves only the need to verify that the base-2 pseudoprimes will all be correctly identified as composite, which is what the verification tests check.

There is no verification test for the miller-rabin bases designed for probabilistic primality testing of numbers < (1<<128), since there's no known way to truly verify this range.  Some testing of various primes and composites in this range does exist in the unit tests in the tests folder at the base of this repository, but performing a few tests is not a verification.  We should keep in mind that even if a failure were were found as a result of using the bases for 128bit numbers, it would not exactly show the bases are wrong, since they were designed for probabilistic testing rather than deterministic testing.  Even so, if we assume the expected probability of any failure of a primality test using these bases is semi-realistic (see MillerRabinProbabilisticBases128.h for details), the existence of even a single pseudoprime to the entire set of the bases would be for practical purposes an impossibility, outside of the context of theory.


Important note on verification correctness
------------------------------------------
The validity of all the 64bit and 63bit and 62bit verification tests in this folder depends upon the correctness of the Feitsma base-2 Fermat pseudoprimes database.  If there are any Fermat base-2 pseudoprimes that are missing from the database, then the miller-rabin bases I generated may be invalid (miller-rabin testing with the bases may mistakenly identify any missing pseudoprime as prime) and the same error(s), if any, would exist in these verifications.  I haven't attempted to verify Feitsma's database.  At least on the surface it appears to be high quality work, and it has been available for 8 years.  I haven't seen any information to suggest it contains mistakes.  This of course is not the same thing as an independent confirmation of correctness, and adding some uncertainty, as far as I know the work has not undergone peer review for an article publication.  Nevertheless I have assumed it is correct, and though it is only a slight help, I found no disagreements with it when using trial-division primality testing over a very limited range of numbers (running for a few days, yet covering less than a millionth of the entire range of uint64_t).
